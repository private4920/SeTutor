{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 42, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rofid/.gemini/antigravity/scratch/SeTutor/src/lib/db/config.ts"],"sourcesContent":["import { Pool, PoolConfig } from \"pg\";\r\n\r\n// Use connectionString if available, otherwise fall back to individual params\r\nconst poolConfig: PoolConfig = process.env.DATABASE_URL\r\n  ? {\r\n      connectionString: process.env.DATABASE_URL,\r\n      ssl: process.env.DATABASE_SSL === \"true\" ? { rejectUnauthorized: false } : false,\r\n      max: 20,\r\n      idleTimeoutMillis: 30000,\r\n      connectionTimeoutMillis: 10000,\r\n    }\r\n  : {\r\n      host: process.env.DATABASE_HOST,\r\n      port: parseInt(process.env.DATABASE_PORT || \"5432\", 10),\r\n      database: process.env.DATABASE_NAME,\r\n      user: process.env.DATABASE_USER,\r\n      password: process.env.DATABASE_PASSWORD,\r\n      ssl: process.env.DATABASE_SSL === \"true\" ? { rejectUnauthorized: false } : false,\r\n      max: 20,\r\n      idleTimeoutMillis: 30000,\r\n      connectionTimeoutMillis: 10000,\r\n    };\r\n\r\nlet pool: Pool | undefined;\r\n\r\nexport function getPool(): Pool {\r\n  if (!pool) {\r\n    pool = new Pool(poolConfig);\r\n  }\r\n  return pool;\r\n}\r\n\r\nexport async function query<T>(text: string, params?: unknown[]): Promise<T[]> {\r\n  const client = await getPool().connect();\r\n  try {\r\n    const result = await client.query(text, params);\r\n    return result.rows as T[];\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\nexport async function closePool(): Promise<void> {\r\n  if (pool) {\r\n    await pool.end();\r\n    pool = undefined;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;;;;;AAEA,8EAA8E;AAC9E,MAAM,aAAyB,QAAQ,GAAG,CAAC,YAAY,GACnD;IACE,kBAAkB,QAAQ,GAAG,CAAC,YAAY;IAC1C,KAAK,QAAQ,GAAG,CAAC,YAAY,KAAK,SAAS;QAAE,oBAAoB;IAAM,IAAI;IAC3E,KAAK;IACL,mBAAmB;IACnB,yBAAyB;AAC3B,IACA;IACE,MAAM,QAAQ,GAAG,CAAC,aAAa;IAC/B,MAAM,SAAS,QAAQ,GAAG,CAAC,aAAa,IAAI,QAAQ;IACpD,UAAU,QAAQ,GAAG,CAAC,aAAa;IACnC,MAAM,QAAQ,GAAG,CAAC,aAAa;IAC/B,UAAU,QAAQ,GAAG,CAAC,iBAAiB;IACvC,KAAK,QAAQ,GAAG,CAAC,YAAY,KAAK,SAAS;QAAE,oBAAoB;IAAM,IAAI;IAC3E,KAAK;IACL,mBAAmB;IACnB,yBAAyB;AAC3B;AAEJ,IAAI;AAEG,SAAS;IACd,IAAI,CAAC,MAAM;QACT,OAAO,IAAI,qJAAI,CAAC;IAClB;IACA,OAAO;AACT;AAEO,eAAe,MAAS,IAAY,EAAE,MAAkB;IAC7D,MAAM,SAAS,MAAM,UAAU,OAAO;IACtC,IAAI;QACF,MAAM,SAAS,MAAM,OAAO,KAAK,CAAC,MAAM;QACxC,OAAO,OAAO,IAAI;IACpB,SAAU;QACR,OAAO,OAAO;IAChB;AACF;AAEO,eAAe;IACpB,IAAI,MAAM;QACR,MAAM,KAAK,GAAG;QACd,OAAO;IACT;AACF"}},
    {"offset": {"line": 107, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rofid/.gemini/antigravity/scratch/SeTutor/src/lib/db/repositories/documentRepository.ts"],"sourcesContent":["import { query } from '../config';\r\nimport { Document, CreateDocumentInput, UpdateDocumentInput } from '../types';\r\n\r\n/**\r\n * All document queries are filtered by user_id to ensure data isolation\r\n * per Requirements 11.1\r\n */\r\n\r\nexport async function createDocument(input: CreateDocumentInput): Promise<Document> {\r\n  const result = await query<Document>(\r\n    `INSERT INTO documents (name, original_name, folder_id, user_id, s3_key, s3_url, file_size, mime_type)\r\n     VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\r\n     RETURNING *`,\r\n    [\r\n      input.name,\r\n      input.original_name,\r\n      input.folder_id || null,\r\n      input.user_id,\r\n      input.s3_key,\r\n      input.s3_url,\r\n      input.file_size,\r\n      input.mime_type\r\n    ]\r\n  );\r\n  if (!result[0]) {\r\n    throw new Error('Failed to create document');\r\n  }\r\n  return result[0];\r\n}\r\n\r\nexport async function getDocumentById(id: string, userId: string): Promise<Document | null> {\r\n  const result = await query<Document>(\r\n    'SELECT * FROM documents WHERE id = $1 AND user_id = $2',\r\n    [id, userId]\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\nexport async function getDocumentsByFolderId(\r\n  folderId: string | null,\r\n  userId: string\r\n): Promise<Document[]> {\r\n  if (folderId === null) {\r\n    return query<Document>(\r\n      'SELECT * FROM documents WHERE folder_id IS NULL AND user_id = $1 ORDER BY name',\r\n      [userId]\r\n    );\r\n  }\r\n  return query<Document>(\r\n    'SELECT * FROM documents WHERE folder_id = $1 AND user_id = $2 ORDER BY name',\r\n    [folderId, userId]\r\n  );\r\n}\r\n\r\nexport async function getAllDocumentsByUserId(userId: string): Promise<Document[]> {\r\n  return query<Document>(\r\n    'SELECT * FROM documents WHERE user_id = $1 ORDER BY created_at DESC',\r\n    [userId]\r\n  );\r\n}\r\n\r\nexport async function getRecentDocuments(userId: string, limit: number = 10): Promise<Document[]> {\r\n  return query<Document>(\r\n    'SELECT * FROM documents WHERE user_id = $1 ORDER BY created_at DESC LIMIT $2',\r\n    [userId, limit]\r\n  );\r\n}\r\n\r\nexport async function searchDocuments(userId: string, searchQuery: string): Promise<Document[]> {\r\n  const searchPattern = `%${searchQuery}%`;\r\n  return query<Document>(\r\n    `SELECT * FROM documents \r\n     WHERE user_id = $1 AND (name ILIKE $2 OR original_name ILIKE $2)\r\n     ORDER BY name`,\r\n    [userId, searchPattern]\r\n  );\r\n}\r\n\r\nexport async function updateDocument(\r\n  id: string,\r\n  userId: string,\r\n  updates: UpdateDocumentInput\r\n): Promise<Document | null> {\r\n  const fields: string[] = [];\r\n  const values: unknown[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (updates.name !== undefined) {\r\n    fields.push(`name = $${paramIndex++}`);\r\n    values.push(updates.name);\r\n  }\r\n  if (updates.folder_id !== undefined) {\r\n    fields.push(`folder_id = $${paramIndex++}`);\r\n    values.push(updates.folder_id);\r\n  }\r\n\r\n  if (fields.length === 0) return getDocumentById(id, userId);\r\n\r\n  values.push(id, userId);\r\n  const result = await query<Document>(\r\n    `UPDATE documents SET ${fields.join(', ')} \r\n     WHERE id = $${paramIndex++} AND user_id = $${paramIndex}\r\n     RETURNING *`,\r\n    values\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\nexport async function deleteDocument(id: string, userId: string): Promise<Document | null> {\r\n  const result = await query<Document>(\r\n    'DELETE FROM documents WHERE id = $1 AND user_id = $2 RETURNING *',\r\n    [id, userId]\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\nexport async function countDocumentsByUserId(userId: string): Promise<number> {\r\n  const result = await query<{ count: string }>(\r\n    'SELECT COUNT(*) as count FROM documents WHERE user_id = $1',\r\n    [userId]\r\n  );\r\n  return parseInt(result[0]?.count ?? '0', 10);\r\n}\r\n\r\nexport async function getDocumentsPaginated(\r\n  userId: string,\r\n  page: number = 1,\r\n  pageSize: number = 20,\r\n  folderId?: string | null\r\n): Promise<{ documents: Document[]; total: number }> {\r\n  const offset = (page - 1) * pageSize;\r\n  \r\n  let countQuery: string;\r\n  let dataQuery: string;\r\n  let params: unknown[];\r\n\r\n  if (folderId === undefined) {\r\n    countQuery = 'SELECT COUNT(*) as count FROM documents WHERE user_id = $1';\r\n    dataQuery = `SELECT * FROM documents WHERE user_id = $1 \r\n                 ORDER BY created_at DESC LIMIT $2 OFFSET $3`;\r\n    params = [userId, pageSize, offset];\r\n  } else if (folderId === null) {\r\n    countQuery = 'SELECT COUNT(*) as count FROM documents WHERE user_id = $1 AND folder_id IS NULL';\r\n    dataQuery = `SELECT * FROM documents WHERE user_id = $1 AND folder_id IS NULL\r\n                 ORDER BY created_at DESC LIMIT $2 OFFSET $3`;\r\n    params = [userId, pageSize, offset];\r\n  } else {\r\n    countQuery = 'SELECT COUNT(*) as count FROM documents WHERE user_id = $1 AND folder_id = $2';\r\n    dataQuery = `SELECT * FROM documents WHERE user_id = $1 AND folder_id = $2\r\n                 ORDER BY created_at DESC LIMIT $3 OFFSET $4`;\r\n    params = [userId, folderId, pageSize, offset];\r\n  }\r\n\r\n  const countResult = await query<{ count: string }>(\r\n    countQuery,\r\n    folderId === undefined ? [userId] : folderId === null ? [userId] : [userId, folderId]\r\n  );\r\n  const documents = await query<Document>(dataQuery, params);\r\n\r\n  return {\r\n    documents,\r\n    total: parseInt(countResult[0]?.count ?? '0', 10)\r\n  };\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 278, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rofid/.gemini/antigravity/scratch/SeTutor/src/lib/db/repositories/folderRepository.ts"],"sourcesContent":["import { query } from '../config';\r\nimport { Folder, CreateFolderInput, UpdateFolderInput } from '../types';\r\n\r\n/**\r\n * All folder queries are filtered by user_id to ensure data isolation\r\n * per Requirements 11.1\r\n */\r\n\r\nexport async function createFolder(input: CreateFolderInput): Promise<Folder> {\r\n  const result = await query<Folder>(\r\n    `INSERT INTO folders (name, parent_id, user_id, path)\r\n     VALUES ($1, $2, $3, $4)\r\n     RETURNING *`,\r\n    [input.name, input.parent_id || null, input.user_id, input.path]\r\n  );\r\n  if (!result[0]) {\r\n    throw new Error('Failed to create folder');\r\n  }\r\n  return result[0];\r\n}\r\n\r\nexport async function getFolderById(id: string, userId: string): Promise<Folder | null> {\r\n  const result = await query<Folder>(\r\n    'SELECT * FROM folders WHERE id = $1 AND user_id = $2',\r\n    [id, userId]\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\nexport async function getFoldersByParentId(\r\n  parentId: string | null,\r\n  userId: string\r\n): Promise<Folder[]> {\r\n  if (parentId === null) {\r\n    return query<Folder>(\r\n      'SELECT * FROM folders WHERE parent_id IS NULL AND user_id = $1 ORDER BY name',\r\n      [userId]\r\n    );\r\n  }\r\n  return query<Folder>(\r\n    'SELECT * FROM folders WHERE parent_id = $1 AND user_id = $2 ORDER BY name',\r\n    [parentId, userId]\r\n  );\r\n}\r\n\r\nexport async function getAllFoldersByUserId(userId: string): Promise<Folder[]> {\r\n  return query<Folder>(\r\n    'SELECT * FROM folders WHERE user_id = $1 ORDER BY path, name',\r\n    [userId]\r\n  );\r\n}\r\n\r\nexport async function updateFolder(\r\n  id: string,\r\n  userId: string,\r\n  updates: UpdateFolderInput\r\n): Promise<Folder | null> {\r\n  const fields: string[] = [];\r\n  const values: unknown[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (updates.name !== undefined) {\r\n    fields.push(`name = $${paramIndex++}`);\r\n    values.push(updates.name);\r\n  }\r\n  if (updates.parent_id !== undefined) {\r\n    fields.push(`parent_id = $${paramIndex++}`);\r\n    values.push(updates.parent_id);\r\n  }\r\n  if (updates.path !== undefined) {\r\n    fields.push(`path = $${paramIndex++}`);\r\n    values.push(updates.path);\r\n  }\r\n\r\n  if (fields.length === 0) return getFolderById(id, userId);\r\n\r\n  values.push(id, userId);\r\n  const result = await query<Folder>(\r\n    `UPDATE folders SET ${fields.join(', ')}, updated_at = CURRENT_TIMESTAMP\r\n     WHERE id = $${paramIndex++} AND user_id = $${paramIndex}\r\n     RETURNING *`,\r\n    values\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\nexport async function deleteFolder(id: string, userId: string): Promise<boolean> {\r\n  const result = await query<{ id: string }>(\r\n    'DELETE FROM folders WHERE id = $1 AND user_id = $2 RETURNING id',\r\n    [id, userId]\r\n  );\r\n  return result.length > 0;\r\n}\r\n\r\nexport async function getFolderPath(id: string, userId: string): Promise<Folder[]> {\r\n  // Recursive CTE to get full folder path from root to current folder\r\n  const result = await query<Folder>(\r\n    `WITH RECURSIVE folder_path AS (\r\n      SELECT * FROM folders WHERE id = $1 AND user_id = $2\r\n      UNION ALL\r\n      SELECT f.* FROM folders f\r\n      INNER JOIN folder_path fp ON f.id = fp.parent_id\r\n      WHERE f.user_id = $2\r\n    )\r\n    SELECT * FROM folder_path ORDER BY path`,\r\n    [id, userId]\r\n  );\r\n  return result;\r\n}\r\n\r\nexport async function getChildFolders(id: string, userId: string): Promise<Folder[]> {\r\n  // Recursive CTE to get all descendant folders\r\n  const result = await query<Folder>(\r\n    `WITH RECURSIVE descendants AS (\r\n      SELECT * FROM folders WHERE parent_id = $1 AND user_id = $2\r\n      UNION ALL\r\n      SELECT f.* FROM folders f\r\n      INNER JOIN descendants d ON f.parent_id = d.id\r\n      WHERE f.user_id = $2\r\n    )\r\n    SELECT * FROM descendants ORDER BY path`,\r\n    [id, userId]\r\n  );\r\n  return result;\r\n}\r\n\r\nexport async function countFoldersByUserId(userId: string): Promise<number> {\r\n  const result = await query<{ count: string }>(\r\n    'SELECT COUNT(*) as count FROM folders WHERE user_id = $1',\r\n    [userId]\r\n  );\r\n  return parseInt(result[0]?.count ?? '0', 10);\r\n}\r\n\r\n/**\r\n * Move a folder to a new parent, updating paths for the folder and all descendants\r\n * Validates that the move doesn't create a circular reference\r\n */\r\nexport async function moveFolder(\r\n  id: string,\r\n  userId: string,\r\n  newParentId: string | null\r\n): Promise<Folder | null> {\r\n  // Get the folder to move\r\n  const folder = await getFolderById(id, userId);\r\n  if (!folder) return null;\r\n\r\n  // Prevent moving to itself\r\n  if (newParentId === id) {\r\n    throw new Error('Cannot move folder into itself');\r\n  }\r\n\r\n  // If moving to a parent, validate it's not a descendant\r\n  if (newParentId) {\r\n    const descendants = await getChildFolders(id, userId);\r\n    if (descendants.some(d => d.id === newParentId)) {\r\n      throw new Error('Cannot move folder into its own descendant');\r\n    }\r\n  }\r\n\r\n  // Calculate new path\r\n  let newPath: string;\r\n  if (newParentId) {\r\n    const newParent = await getFolderById(newParentId, userId);\r\n    if (!newParent) {\r\n      throw new Error('Target parent folder not found');\r\n    }\r\n    newPath = `${newParent.path}/${folder.name}`;\r\n  } else {\r\n    newPath = `/${folder.name}`;\r\n  }\r\n\r\n  // Update the folder\r\n  const updatedFolder = await updateFolder(id, userId, {\r\n    parent_id: newParentId,\r\n    path: newPath\r\n  });\r\n\r\n  // Update paths for all descendants\r\n  if (updatedFolder) {\r\n    const descendants = await getChildFolders(id, userId);\r\n    for (const descendant of descendants) {\r\n      const relativePath = descendant.path.substring(folder.path.length);\r\n      const newDescendantPath = newPath + relativePath;\r\n      await updateFolder(descendant.id, userId, { path: newDescendantPath });\r\n    }\r\n  }\r\n\r\n  return updatedFolder;\r\n}\r\n\r\n\r\nexport async function getFoldersPaginated(\r\n  userId: string,\r\n  page: number = 1,\r\n  pageSize: number = 20,\r\n  parentId?: string | null\r\n): Promise<{ folders: Folder[]; total: number }> {\r\n  const offset = (page - 1) * pageSize;\r\n  \r\n  let countQuery: string;\r\n  let dataQuery: string;\r\n  let countParams: unknown[];\r\n  let dataParams: unknown[];\r\n\r\n  if (parentId === undefined) {\r\n    countQuery = 'SELECT COUNT(*) as count FROM folders WHERE user_id = $1';\r\n    dataQuery = `SELECT * FROM folders WHERE user_id = $1 \r\n                 ORDER BY name LIMIT $2 OFFSET $3`;\r\n    countParams = [userId];\r\n    dataParams = [userId, pageSize, offset];\r\n  } else if (parentId === null) {\r\n    countQuery = 'SELECT COUNT(*) as count FROM folders WHERE user_id = $1 AND parent_id IS NULL';\r\n    dataQuery = `SELECT * FROM folders WHERE user_id = $1 AND parent_id IS NULL\r\n                 ORDER BY name LIMIT $2 OFFSET $3`;\r\n    countParams = [userId];\r\n    dataParams = [userId, pageSize, offset];\r\n  } else {\r\n    countQuery = 'SELECT COUNT(*) as count FROM folders WHERE user_id = $1 AND parent_id = $2';\r\n    dataQuery = `SELECT * FROM folders WHERE user_id = $1 AND parent_id = $2\r\n                 ORDER BY name LIMIT $3 OFFSET $4`;\r\n    countParams = [userId, parentId];\r\n    dataParams = [userId, parentId, pageSize, offset];\r\n  }\r\n\r\n  const countResult = await query<{ count: string }>(countQuery, countParams);\r\n  const folders = await query<Folder>(dataQuery, dataParams);\r\n\r\n  return {\r\n    folders,\r\n    total: parseInt(countResult[0]?.count ?? '0', 10)\r\n  };\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;AAQO,eAAe,aAAa,KAAwB;IACzD,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,CAAC;;gBAEW,CAAC,EACb;QAAC,MAAM,IAAI;QAAE,MAAM,SAAS,IAAI;QAAM,MAAM,OAAO;QAAE,MAAM,IAAI;KAAC;IAElE,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE;QACd,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,MAAM,CAAC,EAAE;AAClB;AAEO,eAAe,cAAc,EAAU,EAAE,MAAc;IAC5D,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,wDACA;QAAC;QAAI;KAAO;IAEd,OAAO,MAAM,CAAC,EAAE,IAAI;AACtB;AAEO,eAAe,qBACpB,QAAuB,EACvB,MAAc;IAEd,IAAI,aAAa,MAAM;QACrB,OAAO,IAAA,qIAAK,EACV,gFACA;YAAC;SAAO;IAEZ;IACA,OAAO,IAAA,qIAAK,EACV,6EACA;QAAC;QAAU;KAAO;AAEtB;AAEO,eAAe,sBAAsB,MAAc;IACxD,OAAO,IAAA,qIAAK,EACV,gEACA;QAAC;KAAO;AAEZ;AAEO,eAAe,aACpB,EAAU,EACV,MAAc,EACd,OAA0B;IAE1B,MAAM,SAAmB,EAAE;IAC3B,MAAM,SAAoB,EAAE;IAC5B,IAAI,aAAa;IAEjB,IAAI,QAAQ,IAAI,KAAK,WAAW;QAC9B,OAAO,IAAI,CAAC,CAAC,QAAQ,EAAE,cAAc;QACrC,OAAO,IAAI,CAAC,QAAQ,IAAI;IAC1B;IACA,IAAI,QAAQ,SAAS,KAAK,WAAW;QACnC,OAAO,IAAI,CAAC,CAAC,aAAa,EAAE,cAAc;QAC1C,OAAO,IAAI,CAAC,QAAQ,SAAS;IAC/B;IACA,IAAI,QAAQ,IAAI,KAAK,WAAW;QAC9B,OAAO,IAAI,CAAC,CAAC,QAAQ,EAAE,cAAc;QACrC,OAAO,IAAI,CAAC,QAAQ,IAAI;IAC1B;IAEA,IAAI,OAAO,MAAM,KAAK,GAAG,OAAO,cAAc,IAAI;IAElD,OAAO,IAAI,CAAC,IAAI;IAChB,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,CAAC,mBAAmB,EAAE,OAAO,IAAI,CAAC,MAAM;iBAC3B,EAAE,aAAa,gBAAgB,EAAE,WAAW;gBAC7C,CAAC,EACb;IAEF,OAAO,MAAM,CAAC,EAAE,IAAI;AACtB;AAEO,eAAe,aAAa,EAAU,EAAE,MAAc;IAC3D,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,mEACA;QAAC;QAAI;KAAO;IAEd,OAAO,OAAO,MAAM,GAAG;AACzB;AAEO,eAAe,cAAc,EAAU,EAAE,MAAc;IAC5D,oEAAoE;IACpE,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,CAAC;;;;;;;2CAOsC,CAAC,EACxC;QAAC;QAAI;KAAO;IAEd,OAAO;AACT;AAEO,eAAe,gBAAgB,EAAU,EAAE,MAAc;IAC9D,8CAA8C;IAC9C,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,CAAC;;;;;;;2CAOsC,CAAC,EACxC;QAAC;QAAI;KAAO;IAEd,OAAO;AACT;AAEO,eAAe,qBAAqB,MAAc;IACvD,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,4DACA;QAAC;KAAO;IAEV,OAAO,SAAS,MAAM,CAAC,EAAE,EAAE,SAAS,KAAK;AAC3C;AAMO,eAAe,WACpB,EAAU,EACV,MAAc,EACd,WAA0B;IAE1B,yBAAyB;IACzB,MAAM,SAAS,MAAM,cAAc,IAAI;IACvC,IAAI,CAAC,QAAQ,OAAO;IAEpB,2BAA2B;IAC3B,IAAI,gBAAgB,IAAI;QACtB,MAAM,IAAI,MAAM;IAClB;IAEA,wDAAwD;IACxD,IAAI,aAAa;QACf,MAAM,cAAc,MAAM,gBAAgB,IAAI;QAC9C,IAAI,YAAY,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,cAAc;YAC/C,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,qBAAqB;IACrB,IAAI;IACJ,IAAI,aAAa;QACf,MAAM,YAAY,MAAM,cAAc,aAAa;QACnD,IAAI,CAAC,WAAW;YACd,MAAM,IAAI,MAAM;QAClB;QACA,UAAU,GAAG,UAAU,IAAI,CAAC,CAAC,EAAE,OAAO,IAAI,EAAE;IAC9C,OAAO;QACL,UAAU,CAAC,CAAC,EAAE,OAAO,IAAI,EAAE;IAC7B;IAEA,oBAAoB;IACpB,MAAM,gBAAgB,MAAM,aAAa,IAAI,QAAQ;QACnD,WAAW;QACX,MAAM;IACR;IAEA,mCAAmC;IACnC,IAAI,eAAe;QACjB,MAAM,cAAc,MAAM,gBAAgB,IAAI;QAC9C,KAAK,MAAM,cAAc,YAAa;YACpC,MAAM,eAAe,WAAW,IAAI,CAAC,SAAS,CAAC,OAAO,IAAI,CAAC,MAAM;YACjE,MAAM,oBAAoB,UAAU;YACpC,MAAM,aAAa,WAAW,EAAE,EAAE,QAAQ;gBAAE,MAAM;YAAkB;QACtE;IACF;IAEA,OAAO;AACT;AAGO,eAAe,oBACpB,MAAc,EACd,OAAe,CAAC,EAChB,WAAmB,EAAE,EACrB,QAAwB;IAExB,MAAM,SAAS,CAAC,OAAO,CAAC,IAAI;IAE5B,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IAEJ,IAAI,aAAa,WAAW;QAC1B,aAAa;QACb,YAAY,CAAC;iDACgC,CAAC;QAC9C,cAAc;YAAC;SAAO;QACtB,aAAa;YAAC;YAAQ;YAAU;SAAO;IACzC,OAAO,IAAI,aAAa,MAAM;QAC5B,aAAa;QACb,YAAY,CAAC;iDACgC,CAAC;QAC9C,cAAc;YAAC;SAAO;QACtB,aAAa;YAAC;YAAQ;YAAU;SAAO;IACzC,OAAO;QACL,aAAa;QACb,YAAY,CAAC;iDACgC,CAAC;QAC9C,cAAc;YAAC;YAAQ;SAAS;QAChC,aAAa;YAAC;YAAQ;YAAU;YAAU;SAAO;IACnD;IAEA,MAAM,cAAc,MAAM,IAAA,qIAAK,EAAoB,YAAY;IAC/D,MAAM,UAAU,MAAM,IAAA,qIAAK,EAAS,WAAW;IAE/C,OAAO;QACL;QACA,OAAO,SAAS,WAAW,CAAC,EAAE,EAAE,SAAS,KAAK;IAChD;AACF"}},
    {"offset": {"line": 514, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rofid/.gemini/antigravity/scratch/SeTutor/src/lib/db/repositories/userRepository.ts"],"sourcesContent":["import { query } from '../config';\r\nimport { User, CreateUserInput } from '../types';\r\n\r\nexport async function createUser(input: CreateUserInput): Promise<User> {\r\n  const result = await query<User>(\r\n    `INSERT INTO users (email, name, photo_url, firebase_uid)\r\n     VALUES ($1, $2, $3, $4)\r\n     RETURNING *`,\r\n    [input.email, input.name, input.photo_url || null, input.firebase_uid]\r\n  );\r\n  if (!result[0]) {\r\n    throw new Error('Failed to create user');\r\n  }\r\n  return result[0];\r\n}\r\n\r\nexport async function getUserById(id: string): Promise<User | null> {\r\n  const result = await query<User>(\r\n    'SELECT * FROM users WHERE id = $1',\r\n    [id]\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\nexport async function getUserByFirebaseUid(firebaseUid: string): Promise<User | null> {\r\n  const result = await query<User>(\r\n    'SELECT * FROM users WHERE firebase_uid = $1',\r\n    [firebaseUid]\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\nexport async function getUserByEmail(email: string): Promise<User | null> {\r\n  const result = await query<User>(\r\n    'SELECT * FROM users WHERE email = $1',\r\n    [email]\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\nexport async function updateUser(\r\n  id: string,\r\n  updates: Partial<Pick<User, 'name' | 'photo_url'>>\r\n): Promise<User | null> {\r\n  const fields: string[] = [];\r\n  const values: unknown[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (updates.name !== undefined) {\r\n    fields.push(`name = $${paramIndex++}`);\r\n    values.push(updates.name);\r\n  }\r\n  if (updates.photo_url !== undefined) {\r\n    fields.push(`photo_url = $${paramIndex++}`);\r\n    values.push(updates.photo_url);\r\n  }\r\n\r\n  if (fields.length === 0) return getUserById(id);\r\n\r\n  values.push(id);\r\n  const result = await query<User>(\r\n    `UPDATE users SET ${fields.join(', ')} WHERE id = $${paramIndex} RETURNING *`,\r\n    values\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\nexport async function deleteUser(id: string): Promise<boolean> {\r\n  const result = await query<{ id: string }>(\r\n    'DELETE FROM users WHERE id = $1 RETURNING id',\r\n    [id]\r\n  );\r\n  return result.length > 0;\r\n}\r\n\r\nexport async function findOrCreateUser(input: CreateUserInput): Promise<User> {\r\n  const existing = await getUserByFirebaseUid(input.firebase_uid);\r\n  if (existing) {\r\n    return existing;\r\n  }\r\n  return createUser(input);\r\n}\r\n\r\n/**\r\n * Get or create a user from a verified Firebase UID\r\n * Used by JWT-authenticated API routes\r\n * \r\n * @param firebaseUid - The verified Firebase UID from the JWT token\r\n * @param email - Optional email from the JWT token\r\n * @param displayName - Optional display name from the JWT token\r\n * @returns The user record\r\n */\r\nexport async function getOrCreateUser(\r\n  firebaseUid: string,\r\n  email: string | null,\r\n  displayName?: string | null\r\n): Promise<User | null> {\r\n  try {\r\n    // First try to get existing user\r\n    const existing = await getUserByFirebaseUid(firebaseUid);\r\n    if (existing) {\r\n      return existing;\r\n    }\r\n\r\n    // Create new user if not found\r\n    // Use displayName, or extract name from email, or use 'User' as fallback\r\n    const name = displayName || (email ? email.split('@')[0] : 'User');\r\n    \r\n    const result = await query<User>(\r\n      `INSERT INTO users (email, name, firebase_uid)\r\n       VALUES ($1, $2, $3)\r\n       ON CONFLICT (firebase_uid) DO UPDATE SET email = EXCLUDED.email\r\n       RETURNING *`,\r\n      [email, name, firebaseUid]\r\n    );\r\n    \r\n    return result[0] || null;\r\n  } catch (error) {\r\n    console.error('Error in getOrCreateUser:', error);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;;;;;AAGO,eAAe,WAAW,KAAsB;IACrD,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,CAAC;;gBAEW,CAAC,EACb;QAAC,MAAM,KAAK;QAAE,MAAM,IAAI;QAAE,MAAM,SAAS,IAAI;QAAM,MAAM,YAAY;KAAC;IAExE,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE;QACd,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,MAAM,CAAC,EAAE;AAClB;AAEO,eAAe,YAAY,EAAU;IAC1C,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,qCACA;QAAC;KAAG;IAEN,OAAO,MAAM,CAAC,EAAE,IAAI;AACtB;AAEO,eAAe,qBAAqB,WAAmB;IAC5D,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,+CACA;QAAC;KAAY;IAEf,OAAO,MAAM,CAAC,EAAE,IAAI;AACtB;AAEO,eAAe,eAAe,KAAa;IAChD,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,wCACA;QAAC;KAAM;IAET,OAAO,MAAM,CAAC,EAAE,IAAI;AACtB;AAEO,eAAe,WACpB,EAAU,EACV,OAAkD;IAElD,MAAM,SAAmB,EAAE;IAC3B,MAAM,SAAoB,EAAE;IAC5B,IAAI,aAAa;IAEjB,IAAI,QAAQ,IAAI,KAAK,WAAW;QAC9B,OAAO,IAAI,CAAC,CAAC,QAAQ,EAAE,cAAc;QACrC,OAAO,IAAI,CAAC,QAAQ,IAAI;IAC1B;IACA,IAAI,QAAQ,SAAS,KAAK,WAAW;QACnC,OAAO,IAAI,CAAC,CAAC,aAAa,EAAE,cAAc;QAC1C,OAAO,IAAI,CAAC,QAAQ,SAAS;IAC/B;IAEA,IAAI,OAAO,MAAM,KAAK,GAAG,OAAO,YAAY;IAE5C,OAAO,IAAI,CAAC;IACZ,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,CAAC,iBAAiB,EAAE,OAAO,IAAI,CAAC,MAAM,aAAa,EAAE,WAAW,YAAY,CAAC,EAC7E;IAEF,OAAO,MAAM,CAAC,EAAE,IAAI;AACtB;AAEO,eAAe,WAAW,EAAU;IACzC,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,gDACA;QAAC;KAAG;IAEN,OAAO,OAAO,MAAM,GAAG;AACzB;AAEO,eAAe,iBAAiB,KAAsB;IAC3D,MAAM,WAAW,MAAM,qBAAqB,MAAM,YAAY;IAC9D,IAAI,UAAU;QACZ,OAAO;IACT;IACA,OAAO,WAAW;AACpB;AAWO,eAAe,gBACpB,WAAmB,EACnB,KAAoB,EACpB,WAA2B;IAE3B,IAAI;QACF,iCAAiC;QACjC,MAAM,WAAW,MAAM,qBAAqB;QAC5C,IAAI,UAAU;YACZ,OAAO;QACT;QAEA,+BAA+B;QAC/B,yEAAyE;QACzE,MAAM,OAAO,eAAe,CAAC,QAAQ,MAAM,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,MAAM;QAEjE,MAAM,SAAS,MAAM,IAAA,qIAAK,EACxB,CAAC;;;kBAGW,CAAC,EACb;YAAC;YAAO;YAAM;SAAY;QAG5B,OAAO,MAAM,CAAC,EAAE,IAAI;IACtB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;IACT;AACF"}},
    {"offset": {"line": 631, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rofid/.gemini/antigravity/scratch/SeTutor/src/lib/firebase/admin.ts"],"sourcesContent":["/**\r\n * Firebase Admin SDK configuration for server-side JWT token verification\r\n * \r\n * This module provides secure backend authentication by verifying Firebase ID tokens.\r\n * It ensures that API requests are authenticated using cryptographically signed JWTs\r\n * rather than trusting client-provided user IDs.\r\n */\r\n\r\nimport { initializeApp, getApps, cert, App } from 'firebase-admin/app';\r\nimport { getAuth, Auth, DecodedIdToken } from 'firebase-admin/auth';\r\n\r\nlet adminApp: App | null = null;\r\nlet adminAuth: Auth | null = null;\r\n\r\n/**\r\n * Initialize Firebase Admin SDK\r\n * Uses environment variables for service account credentials\r\n */\r\nfunction getAdminApp(): App {\r\n  if (adminApp === null) {\r\n    const existingApps = getApps();\r\n    \r\n    if (existingApps.length > 0) {\r\n      adminApp = existingApps[0]!;\r\n    } else {\r\n      // Initialize with service account credentials from environment\r\n      const serviceAccount = process.env.FIREBASE_SERVICE_ACCOUNT_KEY;\r\n      \r\n      if (serviceAccount) {\r\n        // Parse JSON service account key from environment variable\r\n        const credentials = JSON.parse(serviceAccount);\r\n        adminApp = initializeApp({\r\n          credential: cert(credentials),\r\n          projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\r\n        });\r\n      } else {\r\n        // Fallback: Initialize with project ID only (for development with emulator)\r\n        adminApp = initializeApp({\r\n          projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return adminApp;\r\n}\r\n\r\n/**\r\n * Get Firebase Admin Auth instance\r\n */\r\nfunction getAdminAuth(): Auth {\r\n  if (adminAuth === null) {\r\n    adminAuth = getAuth(getAdminApp());\r\n  }\r\n  return adminAuth;\r\n}\r\n\r\n/**\r\n * Verify a Firebase ID token and return the decoded token\r\n * \r\n * @param idToken - The Firebase ID token from the client\r\n * @returns The decoded token containing user information\r\n * @throws Error if token is invalid, expired, or revoked\r\n */\r\nexport async function verifyIdToken(idToken: string): Promise<DecodedIdToken> {\r\n  const auth = getAdminAuth();\r\n  \r\n  try {\r\n    // Verify the token with checkRevoked=true for additional security\r\n    const decodedToken = await auth.verifyIdToken(idToken, true);\r\n    return decodedToken;\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Token verification failed';\r\n    throw new Error(`Invalid authentication token: ${errorMessage}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Authentication result type\r\n */\r\nexport interface AuthResult {\r\n  success: true;\r\n  uid: string;\r\n  email: string | null;\r\n  displayName: string | null;\r\n  emailVerified: boolean;\r\n}\r\n\r\nexport interface AuthError {\r\n  success: false;\r\n  error: string;\r\n  status: number;\r\n}\r\n\r\nexport type AuthResponse = AuthResult | AuthError;\r\n\r\n/**\r\n * Authenticate a request using the Authorization header\r\n * Expects: Authorization: Bearer <firebase-id-token>\r\n * \r\n * @param request - The incoming request\r\n * @returns Authentication result with user info or error\r\n */\r\nexport async function authenticateRequest(request: Request): Promise<AuthResponse> {\r\n  const authHeader = request.headers.get('Authorization');\r\n  \r\n  if (!authHeader) {\r\n    return {\r\n      success: false,\r\n      error: 'Authorization header is required',\r\n      status: 401,\r\n    };\r\n  }\r\n  \r\n  // Extract Bearer token\r\n  const parts = authHeader.split(' ');\r\n  if (parts.length !== 2 || parts[0] !== 'Bearer') {\r\n    return {\r\n      success: false,\r\n      error: 'Invalid authorization format. Expected: Bearer <token>',\r\n      status: 401,\r\n    };\r\n  }\r\n  \r\n  const idToken = parts[1];\r\n  \r\n  if (!idToken || idToken.trim() === '') {\r\n    return {\r\n      success: false,\r\n      error: 'Token is required',\r\n      status: 401,\r\n    };\r\n  }\r\n  \r\n  try {\r\n    const decodedToken = await verifyIdToken(idToken);\r\n    \r\n    return {\r\n      success: true,\r\n      uid: decodedToken.uid,\r\n      email: decodedToken.email || null,\r\n      displayName: decodedToken.name || null,\r\n      emailVerified: decodedToken.email_verified || false,\r\n    };\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Authentication failed';\r\n    return {\r\n      success: false,\r\n      error: errorMessage,\r\n      status: 401,\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;;;;;CAMC,GAED;AACA;;;;;;;;AAEA,IAAI,WAAuB;AAC3B,IAAI,YAAyB;AAE7B;;;CAGC,GACD,SAAS;IACP,IAAI,aAAa,MAAM;QACrB,MAAM,eAAe,IAAA,mNAAO;QAE5B,IAAI,aAAa,MAAM,GAAG,GAAG;YAC3B,WAAW,YAAY,CAAC,EAAE;QAC5B,OAAO;YACL,+DAA+D;YAC/D,MAAM,iBAAiB,QAAQ,GAAG,CAAC,4BAA4B;YAE/D,IAAI,gBAAgB;gBAClB,2DAA2D;gBAC3D,MAAM,cAAc,KAAK,KAAK,CAAC;gBAC/B,WAAW,IAAA,yNAAa,EAAC;oBACvB,YAAY,IAAA,gNAAI,EAAC;oBACjB,SAAS;gBACX;YACF,OAAO;gBACL,4EAA4E;gBAC5E,WAAW,IAAA,yNAAa,EAAC;oBACvB,SAAS;gBACX;YACF;QACF;IACF;IACA,OAAO;AACT;AAEA;;CAEC,GACD,SAAS;IACP,IAAI,cAAc,MAAM;QACtB,YAAY,IAAA,qNAAO,EAAC;IACtB;IACA,OAAO;AACT;AASO,eAAe,cAAc,OAAe;IACjD,MAAM,OAAO;IAEb,IAAI;QACF,kEAAkE;QAClE,MAAM,eAAe,MAAM,KAAK,aAAa,CAAC,SAAS;QACvD,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC9D,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,cAAc;IACjE;AACF;AA4BO,eAAe,oBAAoB,OAAgB;IACxD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IAEvC,IAAI,CAAC,YAAY;QACf,OAAO;YACL,SAAS;YACT,OAAO;YACP,QAAQ;QACV;IACF;IAEA,uBAAuB;IACvB,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,IAAI,MAAM,MAAM,KAAK,KAAK,KAAK,CAAC,EAAE,KAAK,UAAU;QAC/C,OAAO;YACL,SAAS;YACT,OAAO;YACP,QAAQ;QACV;IACF;IAEA,MAAM,UAAU,KAAK,CAAC,EAAE;IAExB,IAAI,CAAC,WAAW,QAAQ,IAAI,OAAO,IAAI;QACrC,OAAO;YACL,SAAS;YACT,OAAO;YACP,QAAQ;QACV;IACF;IAEA,IAAI;QACF,MAAM,eAAe,MAAM,cAAc;QAEzC,OAAO;YACL,SAAS;YACT,KAAK,aAAa,GAAG;YACrB,OAAO,aAAa,KAAK,IAAI;YAC7B,aAAa,aAAa,IAAI,IAAI;YAClC,eAAe,aAAa,cAAc,IAAI;QAChD;IACF,EAAE,OAAO,OAAO;QACd,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC9D,OAAO;YACL,SAAS;YACT,OAAO;YACP,QAAQ;QACV;IACF;AACF"}},
    {"offset": {"line": 752, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rofid/.gemini/antigravity/scratch/SeTutor/src/app/api/dashboard/stats/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport { countDocumentsByUserId } from '@/lib/db/repositories/documentRepository';\r\nimport { countFoldersByUserId } from '@/lib/db/repositories/folderRepository';\r\nimport { getOrCreateUser } from '@/lib/db/repositories/userRepository';\r\nimport { authenticateRequest } from '@/lib/firebase/admin';\r\n\r\n/**\r\n * GET /api/dashboard/stats - Get dashboard statistics\r\n * Headers:\r\n *   - Authorization: Bearer <firebase-id-token> (required)\r\n */\r\nexport async function GET(request: Request) {\r\n  try {\r\n    // Authenticate request using JWT token\r\n    const authResult = await authenticateRequest(request);\r\n    if (!authResult.success) {\r\n      return NextResponse.json(\r\n        { error: authResult.error },\r\n        { status: authResult.status }\r\n      );\r\n    }\r\n\r\n    // Get or create user from verified Firebase UID\r\n    const user = await getOrCreateUser(authResult.uid, authResult.email, authResult.displayName);\r\n    if (!user) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to get user' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // Fetch counts in parallel\r\n    const [documentsCount, foldersCount] = await Promise.all([\r\n      countDocumentsByUserId(user.id),\r\n      countFoldersByUserId(user.id),\r\n    ]);\r\n\r\n    // Flashcards and quizzes counts are placeholders for now\r\n    // Will be implemented when those features are added\r\n    const flashcardsCount = 0;\r\n    const quizzesCount = 0;\r\n\r\n    return NextResponse.json({\r\n      documents: documentsCount,\r\n      folders: foldersCount,\r\n      flashcards: flashcardsCount,\r\n      quizzes: quizzesCount,\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching dashboard stats:', error);\r\n    return NextResponse.json(\r\n      { error: 'Failed to fetch dashboard statistics' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAOO,eAAe,IAAI,OAAgB;IACxC,IAAI;QACF,uCAAuC;QACvC,MAAM,aAAa,MAAM,IAAA,wJAAmB,EAAC;QAC7C,IAAI,CAAC,WAAW,OAAO,EAAE;YACvB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO,WAAW,KAAK;YAAC,GAC1B;gBAAE,QAAQ,WAAW,MAAM;YAAC;QAEhC;QAEA,gDAAgD;QAChD,MAAM,OAAO,MAAM,IAAA,uKAAe,EAAC,WAAW,GAAG,EAAE,WAAW,KAAK,EAAE,WAAW,WAAW;QAC3F,IAAI,CAAC,MAAM;YACT,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAqB,GAC9B;gBAAE,QAAQ;YAAI;QAElB;QAEA,2BAA2B;QAC3B,MAAM,CAAC,gBAAgB,aAAa,GAAG,MAAM,QAAQ,GAAG,CAAC;YACvD,IAAA,kLAAsB,EAAC,KAAK,EAAE;YAC9B,IAAA,8KAAoB,EAAC,KAAK,EAAE;SAC7B;QAED,yDAAyD;QACzD,oDAAoD;QACpD,MAAM,kBAAkB;QACxB,MAAM,eAAe;QAErB,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,WAAW;YACX,SAAS;YACT,YAAY;YACZ,SAAS;QACX;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAuC,GAChD;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}